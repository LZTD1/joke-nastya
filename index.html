<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ловец предметов</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #4CAF50;
            overflow: hidden;
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            -webkit-text-size-adjust: 100%; 
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            background-color: #4CAF50;
        }
        
        #gameCanvas {
            display: block;
            background-color: #4CAF50;
            width: 100%;
            height: 100%;
        }
        
        #gameUI {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .ui-panel {
            background: rgba(0,0,0,0.4);
            padding: 8px;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
            margin-bottom: 10px; 
        }
        
        #score {
            position: absolute;
            top: 10px; /* Adjusted for mobile first approach */
            left: 10px;
            color: white;
            font-size: 18px; /* Default smaller size */
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        #lives {
            position: absolute;
            top: 45px; 
            left: 10px;
            color: white;
            font-size: 16px; /* Default smaller size */
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
         #lives .heart, #lives .empty-heart {
            font-size: 16px;
        }
        #lives div[style*="font-size: 12px"] { 
            font-size: 10px !important;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 12px; /* Smaller for desktop too */
            text-align: right;
            background: rgba(0,0,0,0.5); 
            padding: 8px;
            border-radius: 5px;
            pointer-events: auto;
        }
        
        #sizeControls {
            margin-top: 5px;
        }
        
        .size-control {
            margin: 3px 0;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 5px;
        }
        
        .size-control input {
            width: 45px; /* Smaller inputs */
            padding: 1px 3px;
            font-size: 10px;
        }
        
        .size-control label {
            min-width: auto; /* Allow label to shrink */
            font-size: 10px;
            text-align: right;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px; /* Default smaller size */
            font-weight: bold;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 15px;
            display: none;
            z-index: 20;
            width: 80%;
        }
         #gameOver div[style*="font-size: 24px"] { /* Style for final score text */
            font-size: 18px !important;
            margin: 10px 0 !important;
        }
        #gameOver div[style*="font-size: 18px"] { /* Style for restart text */
            font-size: 14px !important;
        }
        
        #levelProgress {
            position: absolute;
            top: 5px; 
            left: 50%;
            transform: translateX(-50%);
            width: 60%; 
            min-width: 150px; /* Adjusted min-width */
            color: white;
            text-align: center;
            font-size: 12px; /* Default smaller size */
        }
        
        .progress-bar {
            width: 100%;
            height: 15px; /* Default smaller size */
            background: rgba(0,0,0,0.5);
            border-radius: 8px;
            overflow: hidden;
            margin-top: 3px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #81C784);
            border-radius: 8px;
            transition: width 0.3s ease;
        }
        
        #slowdownInfo {
            position: absolute;
            top: 85px; 
            left: 10px;
            color: #FFEB3B; 
            font-size: 12px; /* Default smaller size */
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.9);
            display: none;
            padding: 5px;
        }

        #buffMessage {
            position: absolute;
            top: 40%; 
            left: 50%;
            transform: translate(-50%, -50%);
            color: #81C784; 
            font-size: 20px; /* Default smaller size */
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9);
            background: rgba(0,0,0,0.65);
            padding: 10px 15px;
            border-radius: 10px;
            display: none;
            z-index: 20; 
        }

        #mobileControls {
            position: fixed; /* Use fixed to ensure it's always at the bottom of the viewport */
            bottom: 15px;    /* Adjusted bottom spacing */
            left: 50%;
            transform: translateX(-50%);
            display: none; 
            z-index: 15; 
            gap: 30px; /* Increased gap for better touch separation */
        }

        .mobile-button {
            width: 65px; /* Default smaller size */
            height: 65px;/* Default smaller size */
            background-color: rgba(0, 0, 0, 0.5); /* Slightly less transparent */
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.7); /* Softer border */
            border-radius: 50%;
            font-size: 28px; /* Adjusted font size */
            font-weight: bold;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none; 
            -webkit-tap-highlight-color: transparent; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.3); /* Subtle shadow */
        }

        .mobile-button:active {
            background-color: rgba(0, 0, 0, 0.7);
            transform: scale(0.95); /* Feedback on press */
        }

        /* Desktop specific adjustments (larger screens) */
        @media (min-width: 769px) {
            #score {
                font-size: 24px;
                top: 20px;
                left: 20px;
            }
            #lives {
                font-size: 20px;
                top: 75px;
                left: 20px;
            }
            #lives .heart, #lives .empty-heart {
                font-size: 18px;
            }
            #lives div[style*="font-size: 10px"] { 
                font-size: 12px !important;
            }
            #controls {
                font-size: 14px;
                padding: 10px;
                top: 20px;
                right: 20px;
            }
            #sizeControls { margin-top: 10px; }
            .size-control { margin: 5px 0; gap: 10px; }
            .size-control input { width: 60px; padding: 2px 5px; font-size: 12px;}
            .size-control label { min-width: 80px; font-size: 12px;}

            #gameOver { font-size: 32px; padding: 30px; }
             #gameOver div[style*="font-size: 18px"] { font-size: 24px !important; margin: 15px 0 !important;}
             #gameOver div[style*="font-size: 14px"] { font-size: 18px !important;}


            #levelProgress {
                width: 300px;
                font-size: 14px; /* Larger font for level text on desktop */
                top: 10px;
            }
            .progress-bar { height: 20px; margin-top: 5px; }
            #slowdownInfo {
                font-size: 16px;
                top: 160px;
                left: 20px;
            }
            #buffMessage { font-size: 28px; padding: 15px 25px;}
        }
         /* For very small mobile screens, slightly smaller buttons */
        @media (max-width: 360px) {
            .mobile-button {
                width: 55px;
                height: 55px;
                font-size: 24px;
            }
            #mobileControls {
                gap: 20px;
                bottom: 10px;
            }
        }


    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="gameUI">
            <div id="score" class="ui-panel">Счет: 0</div>
            <div id="lives" class="ui-panel">
                <span id="heartsDisplay"></span>
                <div style="font-size: 12px; margin-top: 5px;">Восстановление: <span id="regenTimer">60</span>с</div>
            </div>
            <div id="levelProgress" class="ui-panel">
                <div>Уровень <span id="level">1</span> - Прогресс</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                </div>
            </div>
             <div id="slowdownInfo" class="ui-panel">Замедление: 20.0с</div>
             <div id="buffMessage"></div>

            <div id="controls">
                <div>Управление: ← → / A D</div>
                <div>Ловите предметы, избегайте врагов!</div>
                <div id="sizeControls">
                    <div class="size-control">
                        <label>Игрок:</label>
                        <input type="number" id="playerSizeInput" value="200" min="20" max="400">
                    </div>
                    <div class="size-control">
                        <label>Предметы:</label>
                        <input type="number" id="itemSizeInput" value="100" min="10" max="150">
                    </div>
                    <div class="size-control">
                        <label>Враги:</label>
                        <input type="number" id="enemySizeInput" value="100" min="10" max="150">
                    </div>
                </div>
            </div>
            <div id="gameOver">
                <div>Игра окончена!</div>
                <div style="font-size: 24px; margin: 15px 0;">Финальный счет: <span id="finalScore">0</span></div>
                <div style="font-size: 18px;">Нажмите R или тапните для перезапуска</div>
            </div>
        </div>
        <div id="mobileControls">
            <button id="moveLeftButton" class="mobile-button">◀</button>
            <button id="moveRightButton" class="mobile-button">▶</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const livesElement = document.getElementById('heartsDisplay');
        const gameOverElement = document.getElementById('gameOver');
        const finalScoreElement = document.getElementById('finalScore');
        const regenTimerElement = document.getElementById('regenTimer');
        const levelElement = document.getElementById('level');
        const progressFillElement = document.getElementById('progressFill');
        const slowdownInfoElement = document.getElementById('slowdownInfo');
        const buffMessageElement = document.getElementById('buffMessage');
        const controlsElement = document.getElementById('controls'); 

        const playerSizeInput = document.getElementById('playerSizeInput');
        const itemSizeInput = document.getElementById('itemSizeInput');
        const enemySizeInput = document.getElementById('enemySizeInput');

        function setCanvasSize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        setCanvasSize(); 

        let score = 0;
        let lives = 5;
        let maxLives = 5;
        let gameRunning = true;
        let animationId;
        let level = 1;
        let gameSpeed = 1.0; 
        let regenTimer = 60;
        let lastRegenTime = Date.now();

        const DEBUFF_DURATION = 20000; 
        let playerOriginalSpeed = 8; 
        let isPlayerSlowed = false;
        let slowdownEndTime = 0;
        let buffMessageTimeout = null;

        // --- Размеры по умолчанию ---
        // Десктоп
        let desktopPlayerSize = 200;
        let desktopItemSize = 100;
        let desktopEnemySize = 100;
        // Мобильные
        let mobilePlayerSize = 90;  // Уменьшено
        let mobileItemSize = 45;    // Уменьшено
        let mobileEnemySize = 45;   // Уменьшено
        let mobileDebafBafSize = 50; // Уменьшено для дебафов/бафов на мобильных

        // Текущие активные размеры (будут меняться в зависимости от режима)
        let currentPlayerSize = desktopPlayerSize;
        let currentItemSize = desktopItemSize;
        let currentEnemySize = desktopEnemySize;
        let currentDebafBafSize = 70; // Дефолтный для десктопа


        const background = new Image();
        background.src = 'bg.png'; 
        background.onerror = function() { console.log('Фоновое изображение не найдено'); };

        const player = {
            x: canvas.width / 2,
            y: canvas.height - 120, 
            baseWidth: 398, baseHeight: 780, // ЗАМЕНИТЕ НА РЕАЛЬНЫЕ ПРОПОРЦИИ GG.PNG
            speed: 8,
            img: new Image()
        };
        playerOriginalSpeed = player.speed;

        function updatePlayerPosition() {
            const playerSize = getPlayerSize();
            player.y = canvas.height - playerSize.height - Math.max(10, canvas.height * 0.02); // Отступ снизу, адаптивный
        }

        function getPlayerSize() {
            let size = currentPlayerSize;
            if (controlsElement.style.display !== 'none' && playerSizeInput.value) { 
                size = parseInt(playerSizeInput.value) || currentPlayerSize;
            }
            return { width: size, height: Math.round(size * (player.baseHeight/player.baseWidth)) };
        }

        const items = [];
        const enemies = [];
        const debafs = []; 
        const bafs = [];   

        const itemTemplate = {
            baseWidth: 292, baseHeight: 323, // ЗАМЕНИТЕ НА РЕАЛЬНЫЕ ПРОПОРЦИИ ITEM.PNG
            speed: 3, img: new Image()
        };
        const enemyTemplate = {
            baseWidth: 386, baseHeight: 379, // ЗАМЕНИТЕ НА РЕАЛЬНЫЕ ПРОПОРЦИИ ENEMY.PNG
            speed: 2.5, img: new Image()
        };
        const debafTemplate = { 
            baseWidth: 162, baseHeight: 163, // ЗАМЕНИТЕ НА РЕАЛЬНЫЕ ПРОПОРЦИИ DEBAF.PNG
            speed: 2.2, img: new Image()
        };
        const bafTemplate = { 
            baseWidth: 139, baseHeight: 154,  // ЗАМЕНИТЕ НА РЕАЛЬНЫЕ ПРОПОРЦИИ BAF.PNG
            speed: 2.8, img: new Image()
        };

        function getItemSize() {
            let size = currentItemSize;
             if (controlsElement.style.display !== 'none' && itemSizeInput.value) {
                size = parseInt(itemSizeInput.value) || currentItemSize;
            }
            return { width: size, height: Math.round(size * (itemTemplate.baseHeight/itemTemplate.baseWidth)) };
        }
        function getEnemySize() {
            let size = currentEnemySize;
             if (controlsElement.style.display !== 'none' && enemySizeInput.value) {
                size = parseInt(enemySizeInput.value) || currentEnemySize;
            }
            return { width: size, height: Math.round(size * (enemyTemplate.baseHeight/enemyTemplate.baseWidth)) };
        }
        
        function getDebafSize() {
            return { width: currentDebafBafSize, height: Math.round(currentDebafBafSize * (debafTemplate.baseHeight/debafTemplate.baseWidth)) };
        }
        function getBafSize() {
             return { width: currentDebafBafSize, height: Math.round(currentDebafBafSize * (bafTemplate.baseHeight/bafTemplate.baseWidth)) };
        }

        player.img.src = 'gg.png'; 
        itemTemplate.img.src = 'item.png'; 
        enemyTemplate.img.src = 'enemy.png'; 
        debafTemplate.img.src = 'debaf.png'; 
        bafTemplate.img.src = 'baf.png'; 

        [player.img, itemTemplate.img, enemyTemplate.img, debafTemplate.img, bafTemplate.img].forEach(img => {
            img.onerror = function() { console.log(`Изображение ${this.src.substring(this.src.lastIndexOf('/')+1)} не найдено`); };
        });

        const keys = {};
        // Флаги для мобильного управления, чтобы избежать конфликта с клавиатурой, если обработчики тач-событий будут активны одновременно с keydown/up
        let moveLeftActive = false;
        let moveRightActive = false;

        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            keys[key] = true; 
            if (key === 'r' && !gameRunning) restartGame();
        });
        document.addEventListener('keyup', (e) => { 
            keys[e.key.toLowerCase()] = false; 
        });

        function createItem() {
            const size = getItemSize();
            items.push({
                x: Math.random() * (canvas.width - size.width), y: -size.height - Math.random() * 50, // Немного разброса по Y
                width: size.width, height: size.height,
                speed: (2 + Math.random() * 1.5) * gameSpeed, 
                img: itemTemplate.img, type: 'item'
            });
        }
        function createEnemy() {
            const size = getEnemySize();
            enemies.push({
                x: Math.random() * (canvas.width - size.width), y: -size.height - Math.random() * 50,
                width: size.width, height: size.height,
                speed: (1.5 + Math.random() * 1) * gameSpeed, 
                img: enemyTemplate.img, type: 'enemy'
            });
        }
        function createDebaf() {
            const size = getDebafSize();
            debafs.push({
                x: Math.random() * (canvas.width - size.width), y: -size.height - Math.random() * 50,
                width: size.width, height: size.height,
                speed: (debafTemplate.speed + Math.random() * 0.5) * gameSpeed,
                img: debafTemplate.img, type: 'debaf'
            });
        }
        function createBaf() {
            const size = getBafSize();
            bafs.push({
                x: Math.random() * (canvas.width - size.width), y: -size.height - Math.random() * 50,
                width: size.width, height: size.height,
                speed: (bafTemplate.speed + Math.random() * 0.5) * gameSpeed,
                img: bafTemplate.img, type: 'baf'
            });
        }

        function updateLevel() {
            const newLevel = Math.floor(score / 100) + 1;
            if (newLevel !== level) {
                level = newLevel;
                gameSpeed = 0.8 + (level - 1) * 0.1; 
                levelElement.textContent = level;
            }
            const progressInLevel = (score % 100) / 100;
            progressFillElement.style.width = (progressInLevel * 100) + '%';
        }

        function getSpawnRates() {
            const baseItemRate = 0.012; // Чуть чаще предметы
            const baseEnemyRate = 0.0035; 
            const baseDebafRate = 0.0005; 
            const baseBafRate = 0.0018;   

            return {
                itemRate: baseItemRate + (level - 1) * 0.004,
                enemyRate: Math.min(baseEnemyRate + (level - 1) * 0.0045, 0.04), 
                debafRate: Math.min(baseDebafRate + (level - 1) * 0.00035, 0.007), 
                bafRate: Math.min(baseBafRate + (level - 1) * 0.0009, 0.018)   
            };
        }
        
        function showTemporaryMessage(element, message, duration) {
            element.textContent = message;
            element.style.display = 'block';
            if (element === buffMessageElement && buffMessageTimeout) {
                clearTimeout(buffMessageTimeout);
            }
            buffMessageTimeout = setTimeout(() => {
                element.style.display = 'none';
            }, duration);
        }

        function updateLives() {
            const now = Date.now();
            const timePassed = (now - lastRegenTime) / 1000;
            if (lives < maxLives) {
                regenTimer -= timePassed;
                if (regenTimer <= 0) {
                    lives = Math.min(maxLives, lives + 1);
                    regenTimer = 60;
                    updateLivesDisplay();
                }
            } else {
                regenTimer = 60;
            }
            regenTimerElement.textContent = Math.ceil(regenTimer);
            lastRegenTime = now;
        }

        function updateLivesDisplay() {
            let heartsHtml = '';
            for (let i = 0; i < maxLives; i++) {
                heartsHtml += (i < lives) ? '<span class="heart">♥</span>' : '<span class="empty-heart">♡</span>';
            }
            livesElement.innerHTML = heartsHtml;
        }

        function updatePlayer() {
            const playerSize = getPlayerSize();
            updatePlayerPosition(); 

            const movingLeft = keys['arrowleft'] || keys['a'] || moveLeftActive;
            const movingRight = keys['arrowright'] || keys['d'] || moveRightActive;

            if (movingLeft && player.x > 0) {
                player.x -= player.speed;
            }
            if (movingRight && player.x < canvas.width - playerSize.width) {
                 player.x += player.speed;
            }
             // Убедимся, что игрок не выходит за границы после движения
            if (player.x < 0) player.x = 0;
            if (player.x > canvas.width - playerSize.width) player.x = canvas.width - playerSize.width;


            if (isPlayerSlowed) {
                const remainingSlowdown = Math.max(0, (slowdownEndTime - Date.now()) / 1000);
                slowdownInfoElement.textContent = `Замедление: ${remainingSlowdown.toFixed(1)}с`;
                if (remainingSlowdown <= 0) {
                    isPlayerSlowed = false;
                    player.speed = playerOriginalSpeed;
                    slowdownInfoElement.style.display = 'none';
                }
            }
        }

        function updateGameObjects(arr, onCollect, onMiss) {
            const playerSize = getPlayerSize(); 
            for (let i = arr.length - 1; i >= 0; i--) {
                const obj = arr[i];
                obj.y += obj.speed;
                if (obj.x + obj.width > player.x && // Правый край объекта > левого края игрока
                    obj.x < player.x + playerSize.width && // Левый край объекта < правого края игрока
                    obj.y + obj.height > player.y && // Нижний край объекта > верхнего края игрока
                    obj.y < player.y + playerSize.height) { // Верхний край объекта < нижнего края игрока
                    onCollect(obj, i); 
                    continue; 
                }
                if (obj.y > canvas.height + 50) { // +50 чтобы точно ушли за экран
                    if (onMiss) onMiss(obj, i); 
                    arr.splice(i, 1);
                }
            }
        }

        function updateItems() {
            updateGameObjects(items, (item, i) => {
                items.splice(i, 1);
                score += 10;
                scoreElement.textContent = `Счет: ${score}`;
                updateLevel();
            });
        }
        function updateEnemies() {
            updateGameObjects(enemies, (enemy, i) => {
                enemies.splice(i, 1);
                lives--;
                updateLivesDisplay();
                if (lives <= 0) endGame();
            });
        }
        function updateDebafs() {
            updateGameObjects(debafs, (debaf, i) => {
                debafs.splice(i, 1);
                if (!isPlayerSlowed) { 
                    isPlayerSlowed = true;
                    player.speed = playerOriginalSpeed / 2; 
                    slowdownEndTime = Date.now() + DEBUFF_DURATION;
                    slowdownInfoElement.style.display = 'block';
                    showTemporaryMessage(buffMessageElement, "ЗАМЕДЛЕНИЕ!", 2000);
                } else { 
                     slowdownEndTime = Date.now() + DEBUFF_DURATION; 
                     showTemporaryMessage(buffMessageElement, "Замедление продлено!", 1500);
                }
            });
        }
        function updateBafs() {
            updateGameObjects(bafs, (baf, i) => {
                bafs.splice(i, 1);
                if (lives < maxLives) {
                    lives++;
                    updateLivesDisplay();
                    showTemporaryMessage(buffMessageElement, "+1 ЖИЗНЬ!", 2000);
                } else {
                    showTemporaryMessage(buffMessageElement, "Здоровье полное!", 1500);
                }
            });
        }

        function drawBackground() {
            if (background.complete && background.naturalWidth > 0) {
                const ar = background.naturalWidth / background.naturalHeight;
                let drawWidth = canvas.width;
                let drawHeight = canvas.width / ar;
                if (drawHeight < canvas.height) { 
                    drawHeight = canvas.height;
                    drawWidth = canvas.height * ar;
                }
                const offsetX = (canvas.width - drawWidth) / 2;
                const offsetY = (canvas.height - drawHeight) / 2;
                ctx.drawImage(background, offsetX, offsetY, drawWidth, drawHeight);
            } else {
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(1, '#4CAF50');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        function drawPlayer() {
            const playerSize = getPlayerSize();
            if (player.img.complete && player.img.naturalWidth > 0) {
                ctx.drawImage(player.img, player.x, player.y, playerSize.width, playerSize.height);
            } else { 
                ctx.fillStyle = '#FF6B6B';
                ctx.fillRect(player.x, player.y, playerSize.width, playerSize.height);
            }
        }

        function drawArray(arr, defaultColor = '#CCCCCC', shape = 'rect') {
            arr.forEach(obj => {
                if (obj.img.complete && obj.img.naturalWidth > 0) {
                    ctx.drawImage(obj.img, obj.x, obj.y, obj.width, obj.height);
                } else { 
                    ctx.fillStyle = defaultColor;
                    if (shape === 'rect') {
                         ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
                    } else if (shape === 'diamond') {
                        ctx.beginPath();
                        ctx.moveTo(obj.x + obj.width/2, obj.y);
                        ctx.lineTo(obj.x + obj.width, obj.y + obj.height/2);
                        ctx.lineTo(obj.x + obj.width/2, obj.y + obj.height);
                        ctx.lineTo(obj.x, obj.y + obj.height/2);
                        ctx.closePath();
                        ctx.fill();
                    } else if (shape === 'triangle') {
                        ctx.beginPath();
                        ctx.moveTo(obj.x + obj.width/2, obj.y);
                        ctx.lineTo(obj.x, obj.y + obj.height);
                        ctx.lineTo(obj.x + obj.width, obj.y + obj.height);
                        ctx.closePath();
                        ctx.fill();
                    }
                }
            });
        }

        function gameLoop() {
            if (!gameRunning) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();

            updatePlayer(); // Обновляем игрока ДО создания новых объектов
            updateItems();
            updateEnemies();
            updateDebafs();
            updateBafs();
            updateLives();

            drawPlayer();
            drawArray(items, '#FFD700', 'diamond');
            drawArray(enemies, '#FF4757', 'triangle');
            drawArray(debafs, '#BCA0DC', 'rect'); 
            drawArray(bafs, '#90EE90', 'rect');   

            const spawnRates = getSpawnRates();
            if (items.length < 10 && Math.random() < spawnRates.itemRate) createItem(); // Ограничение на кол-во предметов
            if (enemies.length < 5 && Math.random() < spawnRates.enemyRate) createEnemy(); // Ограничение на кол-во врагов
            if (debafs.length < 2 && Math.random() < spawnRates.debafRate) createDebaf();
            if (bafs.length < 2 && Math.random() < spawnRates.bafRate) createBaf();


            animationId = requestAnimationFrame(gameLoop);
        }

        function restartGame() {
            score = 0;
            lives = 5;
            level = 1;
            gameSpeed = 0.8; 
            regenTimer = 60;
            lastRegenTime = Date.now();
            
            isPlayerSlowed = false;
            player.speed = playerOriginalSpeed; 
            slowdownInfoElement.style.display = 'none';
            if (buffMessageTimeout) clearTimeout(buffMessageTimeout);
            buffMessageElement.style.display = 'none';

            scoreElement.textContent = `Счет: ${score}`;
            levelElement.textContent = level;
            progressFillElement.style.width = '0%';
            updateLivesDisplay();
            
            items.length = 0; enemies.length = 0; debafs.length = 0; bafs.length = 0;
            
            updatePlayerPosition(); // Устанавливаем Y
            player.x = canvas.width / 2 - getPlayerSize().width / 2; // Центрируем X

            gameRunning = true;
            gameOverElement.style.display = 'none';
            if (animationId) cancelAnimationFrame(animationId); // Отменяем предыдущий цикл, если был
            gameLoop();
        }

        function endGame() {
            gameRunning = false;
            finalScoreElement.textContent = score;
            gameOverElement.style.display = 'block';
            cancelAnimationFrame(animationId);
        }

        const moveLeftButton = document.getElementById('moveLeftButton');
        const moveRightButton = document.getElementById('moveRightButton');
        const mobileControlsElement = document.getElementById('mobileControls');

        function isTouchDevice() {
            return (('ontouchstart' in window) ||
                   (navigator.maxTouchPoints > 0) ||
                   (navigator.msMaxTouchPoints > 0));
        }

        function setupControlsBasedOnDevice() {
            const touchDevice = isTouchDevice();
            const narrowWindow = window.innerWidth <= 768;

            if (touchDevice || narrowWindow) {
                mobileControlsElement.style.display = 'flex';
                controlsElement.style.display = 'none'; 

                currentPlayerSize = mobilePlayerSize;
                currentItemSize = mobileItemSize;
                currentEnemySize = mobileEnemySize;
                currentDebafBafSize = mobileDebafBafSize;

                playerSizeInput.value = currentPlayerSize;
                itemSizeInput.value = currentItemSize;
                enemySizeInput.value = currentEnemySize;
            } else {
                 mobileControlsElement.style.display = 'none';
                 controlsElement.style.display = 'block'; 
                 currentPlayerSize = desktopPlayerSize;
                 currentItemSize = desktopItemSize;
                 currentEnemySize = desktopEnemySize;
                 currentDebafBafSize = 70; // Desktop default for baf/debaf

                 playerSizeInput.value = currentPlayerSize;
                 itemSizeInput.value = currentItemSize;
                 enemySizeInput.value = currentEnemySize;
            }
        }
        
        // Обработчики для мобильных кнопок
        moveLeftButton.addEventListener('touchstart', (e) => {
            e.preventDefault(); 
            moveLeftActive = true;
        }, { passive: false }); 
        moveLeftButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            moveLeftActive = false;
        }, { passive: false });

        moveRightButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            moveRightActive = true;
        }, { passive: false });
        moveRightButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            moveRightActive = false;
        }, { passive: false });

        // Рестарт по тапу на GameOver
        gameOverElement.addEventListener('click', () => { // Click для десктопа тоже
             if (!gameRunning) restartGame();
        });
         gameOverElement.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameRunning) restartGame();
        }, { passive: false });


        window.addEventListener('resize', () => {
            setCanvasSize();
            setupControlsBasedOnDevice(); 
            updatePlayerPosition(); 
            const pSize = getPlayerSize();
            if (player.x > canvas.width - pSize.width) player.x = canvas.width - pSize.width;
            if (player.x < 0) player.x = 0;
        });
        
        // Инициализация
        setupControlsBasedOnDevice(); 
        updateLivesDisplay();
        updatePlayerPosition(); 
        player.x = canvas.width / 2 - getPlayerSize().width / 2; 
        gameLoop();
    </script>
</body>
</html>
